<!doctype html>
<html lang="en">

<head>
<meta charset="utf-8">
<title>Spring v4.x</title>

<meta name="description" content="spring framework">
<meta name="author" content="J. Ignacio Reta Sabarrós">

<link rel="stylesheet" type="text/css" href="http://spring.io/css/main.css">
<link rel="stylesheet" href="bower_components/reveal.js/css/reveal.css">
<link rel="stylesheet" href="bower_components/reveal.js/css/theme/league.css" id="theme">
<link rel="stylesheet" href="lib/css/zenburn.css">


</head>

<body>
  <div class="reveal">
  <div class="slides">
    <section>
      <section>
        <div class="icon icon-spring-logo-big homepage-icon"></div>

        <h1>Spring Framework</h1>
        <h3>Ayuda para el desarrollo de aplicaciones y contenedor de inyección de dependencias</h3>
      </section>
      <section>
        Todos los ejemplos que vamos a enseñar son código java. <br>
        Todos los conceptos son aplicables a otras tecnologías que usen
        el paradigma de orientación a objetos.
      </section>
      <section data-markdown>
        <script type="text/template">
          ### Vamos a hablar de:
          * Inyección de dependencias
          * ApplicationContext vs. BeanFactory
          * Ciclo de vida de los beans y más configuración
          * Testeo + inyección de dependencias
          * Spring data + JPA
          * Spring batch + schedule
        </script>
      </section>
    </section>

    <section>
      <section data-markdown>
        <script type="text/template">
          ## Comencemos con inyección de dependencias
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ### Vamos a ver un ejemplo muy sencillo de inyección de dependencias.
          * Tenemos una agenda de contactos <!-- .element: class="fragment" data-fragment-index="1" -->
          * Queremos imprimir toda la agenda de contactos <!-- .element: class="fragment" data-fragment-index="2" -->
          </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ### Implementación
          * Nuestra agenda será un properties <!-- .element: class="fragment" data-fragment-index="1" -->
          * Necesitamos "algo" para mostrar por pantalla la información de todos los contactos <!-- .element: class="fragment" data-fragment-index="2" -->
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ## ¡A JUGAR!
          ### Paso 01
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          * En nuestro ejemplo lo hemos implementado dentro del constructor de la clase
          * Supongamos ahora que otros desarrolladores quieren utilizar la funcionalidad
            pero <!-- .element: class="fragment" data-fragment-index="1" -->
            * Usan un formato de fichero distinto al mío <!-- .element: class="fragment" data-fragment-index="2" -->
            **UPS!** <!-- .element: class="fragment" data-fragment-index="4" -->
            * Usan el mismo formato, pero el fichero se llama de distinta manera o está
              en otro directorio <!-- .element: class="fragment" data-fragment-index="5" -->
            **UPS!**<!-- .element: class="fragment" data-fragment-index="6" -->
            * Lo tienen en una base de datos <!-- .element: class="fragment" data-fragment-index="7" -->
            **UPS! UPS! UPS! GULP! ARGGG! OMFG!! ** <!-- .element: class="fragment" data-fragment-index="8" -->
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ### Podemos definir ContactoServicios como una interfaz e implementar distintos comportamientos según los requisitos
          * Pero seguimos teniendo que crear el objeto de la implementación concreta en algún sitio. <!-- .element: class="fragment" data-fragment-index="1" -->
          * Resumiendo tendríamos algo que se parece a... <!-- .element: class="fragment" data-fragment-index="1" -->
        </script>
      </section>
      <section>
        <img src="img/interfaz.png"/>
      </section>
      <section data-markdown>
        <script type="text/template">
          ## ¡A JUGAR!
          ### Paso 02
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          * Podemos tener muchas implementaciones de ContactoDAO y
            conseguir que todas funcionen gracias a referencias solamente a la interfaz.
          * Si queremos poder usar el programa con las diferentes implementaciones
            según la situación sin que afecte a Agenda, necesitamos un mecanismo
            que ensamble la implementación que necesitamos en cada caso.
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          * Para resolver este problema existe toda una serie de frameworks ligeros
            como Spring Framework, Google Guice o PicoContainer.
          * Todos ellos usan la Inversión de Control (IoC) para abordar el problema.
          * La idea básica es que se creará un elemento extra que será el encargado
            de poblar el campo ContactosDAO de la clase Agenda con la implementación
            correcta.
          * La representación de la aplicación quedaría algo similar a… 
        </script>
      </section>
      <section>
        <img src="img/inyectorDependencias.png"/>
      </section>
      <section data-markdown>
        <script type="text/template">
          * Hay 3 tipos de inyección de dependencies
            * basadas en contructor
            * basadas en setters
            * basadas en interfaces
          * La mayoría de los frameworks soportan las basadas en constructor y setters
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ## Veamos como queda nuestro código con Spring Framework
          ### Paso 03
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          * La inyección de dependencias nos permite mantener nuestro código débilmente
            acoplado, ganando en mantenibilidad.
          * Además, permite una manera sencilla de construir test introduciendo clases
            mock o clases específicas para forzar determinados comportamientos.
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ## ¿Dónde está el éxito de Spring?
          ### ¿Se debe únicamente a la facilidad de mantenimiento y de construcción de tests?
          * Es un motivo de mucho peso
          * Pero no es el único
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          * Creación de objetos mucho más complejos con muchas dependencias
          * Creación de objetos de lógica (y posterior destrucción) de forma innecesarias
            en entornos altamente concurrentes como aplicaciones web:
            * Clases de lógica sin estado
            * Clases de lógica con estado
            * Clases de lógica con estado en cada ejecución
            * Facilidad de integración con otros frameworks/tecnologías
              * JMS
              * JDBC
              * RestFULL
              * …
        </script>
      </section>
    </section>

    <section>
      <section data-markdown>
        <script type="text/template">
          ## Introducción a Spring
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ##IoC ofrecidos por Spring
          * BeanFactory
          * ApplicationContext
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ## ApplicationContext vs BeanFactory
          * Proporciona soporte I18n para mensajes de texto
          * Proporciona forma genérica de cargar recursos, como imágenes
          * Puede publicar eventos a beans que están registrados como _listeners_
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ## Tipos de _BeanFactory_
          * XmlBeanFactory (indicará como se cargará el xml de definición)
            * ClassPathResource
            * FileSystemResource
            * InputStreamResource
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ### Ejemplo de BeanFactory
          <div>Paso 04 - BeanFactoryMain</div>
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ## Tipos de _ApplicationContext_
          * ClassPathXmlApplicationContext
          * FileSystemXmlApplicationContext
          * XmlWebApplicationContext
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ### Ejemplo de ApplicationContext
          <div >Paso 04 - ApplicationContextMain</div>
        </script>
      </section>
      <section>
        <h2>Relación entre ellos</h2>
        <img src="img/jerarquiaBeans.png"/>
      </section>
      <section data-markdown>
        <script type="text/template">
          ## Configuración basada en XML
          * <!-- .element: class="fragment" data-fragment-index="1" -->
            id/name<!-- .element: class="fragment" data-fragment-index="2" -->
            _: nombre por el que se hará referencia al bean.
            En caso de no definir ninguno, se sigue la convención del nombre de
            la clase con la primera letra en minúscula._<!-- .element: class="fragment" data-fragment-index="3" -->
          * <!-- .element: class="fragment" data-fragment-index="4" -->
            class<!-- .element: class="fragment" data-fragment-index="5" -->
            _: nombre completo de la clase que implementará el bean en cuestión._<!-- .element: class="fragment" data-fragment-index="6" -->
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          * scope
            _: "alcance" que tiene el bean que se define._<!-- .element: class="fragment" data-fragment-index="1" -->
          * <!-- .element: class="fragment" data-fragment-index="2" -->
            constructor-arg<!-- .element: class="fragment" data-fragment-index="3" -->
            _: definición de los argumentos que serán necesarios proporcionar al constructor de la clase._<!-- .element: class="fragment" data-fragment-index="4" -->
          * <!-- .element: class="fragment" data-fragment-index="5" -->
            properties<!-- .element: class="fragment" data-fragment-index="6" -->
            _: forma de invocar la inyección por dependencias a través de los setters. _<!-- .element: class="fragment" data-fragment-index="7" -->
          * <!-- .element: class="fragment" data-fragment-index="8" -->
            autowire<!-- .element: class="fragment" data-fragment-index="9" -->
            _: define la forma de resolver las depenencias en las relaciones de objetos._<!-- .element: class="fragment" data-fragment-index="10" -->
          * <!-- .element: class="fragment" data-fragment-index="11" -->
            lazy-init<!-- .element: class="fragment" data-fragment-index="12" -->
            _: especifica si el bean se crea en el momento de arrancar la aplicación o se crea en el momento en el que
            se va a utilizar por primera vez. Se puede definir a nivel de bean individual
            o a nivel de un conjunto de beans (default-lazy-init)._<!-- .element: class="fragment" data-fragment-index="13" -->
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          * init-method
            _: define que método será llamado para crear la instancia del bean.
              Por convención será el constructor que corresponda, pero puede ser cualquier método._<!-- .element: class="fragment" data-fragment-index="1" -->
          * <!-- .element: class="fragment" data-fragment-index="2" -->
            destroy-method<!-- .element: class="fragment" data-fragment-index="3" -->
            _: define que método será el que se ejecute al final del ciclo de vida del bean, antes de ser destruido._<!-- .element: class="fragment" data-fragment-index="4" -->
        </script>
      </section>
      <section>
        <h3>Ejemplo</h3>
        <div>Paso 04 - ConfigXmlMain</div>
      </section>
      <section data-markdown>
        <script type="text/template">
          ## Singletons y factorías
          * Spring ofrece una forma cómoda de crear instancias de objetos utilizando
            factorías para ello.
          * Por defecto, cada bean que se instancia es una única instancia común
            a todas las veces que se utilice.
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ## Factorías
          * Por defecto, usa el constructor que mejor se adapte a los parámetros
            que se definan por configuración.
          * Se puede usar un _Factory Method_ de creación concreto.
          * Se puede usar un _AbstractFactory_ para crear objetos.
        </script>
      </section>
      <section >
        <h2>Ejemplo</h2>
        <pre><code data-trim>
<beans>
  <bean id="bean1" class="...">
    <constructor-arg ref="bean2"></constructor-arg>
  </bean>

  <bean id="bean2" class="..." factory-method="makeInstance"></bean>

  <bean id="bean3" class="..."
    factory-bean="factoryService"
    factory-method="makeInstanceBean3"
  ></bean>

  <bean id="bean4" class="..."
    factory-bean="factoryService"
    factory-method="makeInstanceBean4"
  ></bean>

  <bean id="facotryService" class="..."></bean>
</beans>
        </code></pre>
        <div>Paso 04 - FactoryMain</div>
      </section>

      <section data-markdown>
        <script type="text/template">
          ## Configuración en múltiples ficheros
          * Se pueden definir todos los beans en un único fichero de configuración.
            Se acaba teniendo un fichero con miles de beans.
          * Se pueden definir los beans agrupados siguiendo algún criterio y referenciarlos.
        </script>
      </section>
      <section>
        <h2>Ejemplo</h2>
        <pre><code data-trim>
<beans>
  <bean id="bean1" class="..."></bean>
  <bean id="bean2" class="..."></bean>

  <import resource="services.xml"></import>
  <import resource="resources/services.xml"></import>
  <import resource="/resources/services.xml"></import>
</beans>
        </code></pre>
        <div>Paso 04 - CompositeConfigMain</div>
      </section>
    </section>



  </div>
  </div>
  <script type="text/javascript" src="bower_components/reveal.js/lib/js/head.min.js"></script>
  <script type="text/javascript" src="bower_components/reveal.js/js/reveal.js"></script>

  <script>
      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
          controls: true,
          progress: true,
          history: true,
          keyboard: true,
          center: true,
          hideAddressBar: true,

          theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
          transition: Reveal.getQueryHash().transition || 'concave', // default/cube/page/concave/zoom/linear/none

          dependencies: [
  					{ src: 'bower_components/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
  					{ src: 'bower_components/reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
            { src: 'bower_components/reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
            { src: 'bower_components/reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
  					{ src: 'bower_components/reveal.js/plugin/notes/notes.js' }
  				]
      });
  </script>
</body>
</html>
