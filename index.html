<!doctype html>
<html lang="en">

<head>
<meta charset="utf-8">
<title>Spring v4.0</title>

<meta name="description" content="spring framework">
<meta name="author" content="J. Ignacio Reta Sabarrós">

<link rel="stylesheet" type="text/css" href="http://spring.io/css/main.css">
<link rel="stylesheet" href="bower_components/reveal.js/css/reveal.css">
<link rel="stylesheet" href="bower_components/reveal.js/css/theme/league.css" id="theme">
<link rel="stylesheet" href="lib/css/zenburn.css">


</head>

<body>
  <div class="reveal">
  <div class="slides">
    <section>
      <section>
        <div class="icon icon-spring-logo-big homepage-icon"></div>

        <h1>Spring Framework</h1>
        <h3>Ayuda para el desarrollo de aplicaciones y contenedor de inyección de dependencias</h3>
      </section>
      <section>
        Todos los ejemplos que vamos a enseñar son código java. <br>
        Todos los conceptos son aplicables a otras tecnologías que usen
        el paradigma de orientación a objetos.
      </section>
      <section data-markdown>
        <script type="text/template">
          ### Vamos a hablar de:
          * Inyección de dependencias
          * ApplicationContext vs. BeanFactory
          * Ciclo de vida de los beans y más configuración
          * Testeo + inyección de dependencias
          * Spring data + JPA
          * Spring batch + schedule
        </script>
      </section>
    </section>

    <section>
      <section data-markdown>
        <script type="text/template">
          ## Comencemos con inyección de dependencias
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ### Vamos a ver un ejemplo muy sencillo de inyección de dependencias.
          * Tenemos una agenda de contactos <!-- .element: class="fragment" data-fragment-index="1" -->
          * Queremos imprimir toda la agenda de contactos <!-- .element: class="fragment" data-fragment-index="2" -->
          </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ### Implementación
          * Nuestra agenda será un properties <!-- .element: class="fragment" data-fragment-index="1" -->
          * Necesitamos "algo" para mostrar por pantalla la información de todos los contactos <!-- .element: class="fragment" data-fragment-index="2" -->
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ## ¡A JUGAR!
          ### Paso 01
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          * En nuestro ejemplo lo hemos implementado dentro del constructor de la clase
          * Supongamos ahora que otros desarrolladores quieren utilizar la funcionalidad
            pero <!-- .element: class="fragment" data-fragment-index="1" -->
            * Usan un formato de fichero distinto al mío <!-- .element: class="fragment" data-fragment-index="2" -->
            **UPS!** <!-- .element: class="fragment" data-fragment-index="4" -->
            * Usan el mismo formato, pero el fichero se llama de distinta manera o está
              en otro directorio <!-- .element: class="fragment" data-fragment-index="5" -->
            **UPS!**<!-- .element: class="fragment" data-fragment-index="6" -->
            * Lo tienen en una base de datos <!-- .element: class="fragment" data-fragment-index="7" -->
            **UPS! UPS! UPS! GULP! ARGGG! OMFG!! ** <!-- .element: class="fragment" data-fragment-index="8" -->
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ### Podemos definir ContactoServicios como una interfaz e implementar distintos comportamientos según los requisitos
          * Pero seguimos teniendo que crear el objeto de la implementación concreta en algún sitio. <!-- .element: class="fragment" data-fragment-index="1" -->
          * Resumiendo tendríamos algo que se parece a... <!-- .element: class="fragment" data-fragment-index="1" -->
        </script>
      </section>
      <section>
        <img src="img/interfaz.png"/>
      </section>
      <section data-markdown>
        <script type="text/template">
          ## ¡A JUGAR!
          ### Paso 02
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          * Podemos tener muchas implementaciones de ContactoDAO y
            conseguir que todas funcionen gracias a referencias solamente a la interfaz.
          * Si queremos poder usar el programa con las diferentes implementaciones
            según la situación sin que afecte a Agenda, necesitamos un mecanismo
            que ensamble la implementación que necesitamos en cada caso.
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          * Para resolver este problema existe toda una serie de frameworks ligeros
            como Spring Framework, Google Guice o PicoContainer.
          * Todos ellos usan la Inversión de Control (IoC) para abordar el problema.
          * La idea básica es que se creará un elemento extra que será el encargado
            de poblar el campo ContactosDAO de la clase Agenda con la implementación
            correcta.
          * La representación de la aplicación quedaría algo similar a… 
        </script>
      </section>
      <section>
        <img src="img/inyectorDependencias.png"/>
      </section>
      <section data-markdown>
        <script type="text/template">
          * Hay 3 tipos de inyección de dependencies
            * basadas en contructor
            * basadas en setters
            * basadas en interfaces
          * La mayoría de los frameworks soportan las basadas en constructor y setters
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ## Veamos como queda nuestro código con Spring Framework
          ### Paso 03
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          * La inyección de dependencias nos permite mantener nuestro código débilmente
            acoplado, ganando en mantenibilidad.
          * Además, permite una manera sencilla de construir test introduciendo clases
            mock o clases específicas para forzar determinados comportamientos.
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          ## ¿Dónde está el éxito de Spring?
          ### ¿Se debe únicamente a la facilidad de mantenimiento y de construcción de tests?
          * Es un motivo de mucho peso
          * Pero no es el único
        </script>
      </section>
      <section data-markdown>
        <script type="text/template">
          * Creación de objetos mucho más complejos con muchas dependencias
          * Creación de objetos de lógica (y posterior destrucción) de forma innecesarias
            en entornos altamente concurrentes como aplicaciones web:
            * Clases de lógica sin estado
            * Clases de lógica con estado
            * Clases de lógica con estado en cada ejecución
            * Facilidad de integración con otros frameworks/tecnologías
              * JMS
              * JDBC
              * Colas
              * …
        </script>
      </section>
    </section>



  </div>
  </div>
  <script type="text/javascript" src="bower_components/reveal.js/lib/js/head.min.js"></script>
  <script type="text/javascript" src="bower_components/reveal.js/js/reveal.js"></script>

  <script>
      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
          controls: true,
          progress: true,
          history: true,
          keyboard: true,
          center: true,
          hideAddressBar: true,

          theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
          transition: Reveal.getQueryHash().transition || 'concave', // default/cube/page/concave/zoom/linear/none

          dependencies: [
  					{ src: 'bower_components/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
  					{ src: 'bower_components/reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
            { src: 'bower_components/reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
            { src: 'bower_components/reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
  					{ src: 'bower_components/reveal.js/plugin/notes/notes.js' }
  				]
      });
  </script>
</body>
</html>
